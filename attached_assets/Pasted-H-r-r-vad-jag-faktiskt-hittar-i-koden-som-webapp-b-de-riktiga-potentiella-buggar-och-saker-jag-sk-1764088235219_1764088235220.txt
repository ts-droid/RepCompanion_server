H√§r √§r vad jag faktiskt hittar i koden som webapp ‚Äì b√•de riktiga/potentiella buggar och saker jag skulle fixa f√∂r att g√∂ra den stabilare och trevligare att jobba med fram√•t.

Obs: Vissa filer i zippen √§r uppenbart trunkerade (med ‚Äú‚Ä¶‚Äù/ellips i st√§llet f√∂r riktig kod, t.ex. ThemeContext.tsx, Dashboard.tsx). D√§r kan jag inte g√∂ra en full review, s√• nedan fokuserar jag p√• de delar d√§r koden √§r komplett.

1. Konkreta buggar / tydliga fotanglar
1.1 Avatar-bildkomprimering kan ‚Äúh√§nga‚Äù

Fil: client/src/components/AvatarSelector.tsx

async function compressImage(file: File): Promise<File> {
  return new Promise((resolve) => {
    ...
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx) return;              // ‚¨ÖÔ∏è h√§r
      ...
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(
            new File([blob], file.name, {
              type: "image/jpeg",
              lastModified: Date.now(),
            })
          );
        }
      }, "image/jpeg", 0.8);
    };
  });
}


Problem:

Om canvas.getContext("2d") returnerar null ‚Üí funktionen returnerar fr√•n onload-callbacken, men Promise:en varken resolve eller reject:ar.

Om canvas.toBlob anropas men ger null blob h√§nder samma sak (bara tyst if (blob) { ... }).

I b√•da fallen kan await compressImage(file) inneb√§ra att UI:t fastnar i ‚Äúladdar upp‚Äù-l√§ge utan att n√•got h√§nder.

Fixf√∂rslag:

G√∂r s√• att Promise alltid avslutas:

async function compressImage(file: File): Promise<File> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onerror = (err) => {
      console.error("Avatar FileReader error", err);
      resolve(file); // eller reject(err) om du vill h√•rd-faila
    };

    reader.onload = (e) => {
      const img = new Image();
      img.src = e.target?.result as string;

      img.onerror = (err) => {
        console.error("Avatar image load error", err);
        resolve(file);
      };

      img.onload = () => {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          console.warn("No 2D context, skipping compression");
          return resolve(file);
        }

        // ‚Ä¶ skala width/height ‚Ä¶

        canvas.toBlob((blob) => {
          if (!blob) {
            console.warn("Canvas.toBlob returned null, skipping compression");
            return resolve(file);
          }

          resolve(
            new File([blob], file.name, {
              type: "image/jpeg",
              lastModified: Date.now(),
            }),
          );
        }, "image/jpeg", 0.8);
      };
    };

    reader.readAsDataURL(file);
  });
}

1.2 Health Connect ‚Äì spinner + polling kan fastna

Fil: client/src/components/HealthConnectButton.tsx

const { data: connections = [], refetch: refetchConnections } = useQuery<HealthConnection[]>({
  queryKey: ['/api/health/connections'],
});

const handleConnect = async () => {
  setIsConnecting(true);
  try {
    const res = await apiRequest('POST', '/api/health/connect');
    const response = await res.json() as { success: boolean; linkUrl: string; linkToken: string };

    if (response.success && response.linkUrl) {
      window.open(response.linkUrl, '_blank', 'width=500,height=700');
      
      const checkInterval = setInterval(async () => {
        const updatedConnections = await refetchConnections();
        if (updatedConnections.data && updatedConnections.data.length > connections.length) {
          clearInterval(checkInterval);
          setIsConnecting(false);
        }
      }, 5000);
    }
  } catch (error: any) {
    console.error('Failed to initiate Health Connect flow:', error);
    setIsConnecting(false);
    ...
  }
};


Problem:

Om API:t svarar utan success === true eller utan linkUrl:

isConnecting f√∂rblir true ‚Üí knappen sitter i ‚Äúconnecting‚Äù-state f√∂r alltid.

Inget toast till anv√§ndaren.

setInterval:

Anv√§nder connections.length som j√§mf√∂relsev√§rde ‚Äì det √§r v√§rdet vid klicket (stale closure).

Intervallen rensas bara n√§r length > connections.length. Om anv√§ndaren aldrig slutf√∂r kopplingen k√∂rs intervallet i evighet.

Ingen cleanup i useEffect om komponenten skulle unmountas med ett aktivt interval.

Fixf√∂rslag:

S√§kerst√§ll att isConnecting alltid nollst√§lls:

Spara ‚Äúbaseline‚Äù‚Äìantalet i en ref eller lokalt i handleConnect.

L√§gg till cleanup.

const baselineCountRef = useRef(0);

const handleConnect = async () => {
  setIsConnecting(true);
  baselineCountRef.current = connections.length;

  try {
    const res = await apiRequest('POST', '/api/health/connect');
    const response = await res.json() as { success?: boolean; linkUrl?: string };

    if (!response.success || !response.linkUrl) {
      setIsConnecting(false);
      toast({
        title: "Kunde inte starta koppling",
        description: "F√∂rs√∂k igen om en stund.",
        variant: "destructive",
      });
      return;
    }

    const popup = window.open(response.linkUrl, '_blank', 'width=500,height=700');

    const intervalId = window.setInterval(async () => {
      const updated = await refetchConnections();
      const len = updated.data?.length ?? 0;
      if (len > baselineCountRef.current) {
        window.clearInterval(intervalId);
        setIsConnecting(false);
        toast({ title: "Koppling klar", description: "Din h√§lsodata synkas nu üéâ" });
      }
      // ev. √§ven: om popup st√§ngs ‚Üí clearInterval + setIsConnecting(false)
    }, 5000);
  } catch (error) {
    console.error("Failed to initiate Health Connect flow:", error);
    setIsConnecting(false);
    toast({ ... });
  }
};


Och g√§rna l√§gga interval‚Äìid:t i en ref och rensa i en useEffect-cleanup ocks√•.

1.3 useIsMobile ‚Äì framtida kompatibilitet & edge case

Fil: client/src/hooks/use-mobile.tsx

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


Problem / risk som webapp:

Funkar i moderna browsers, men:

√Ñldre Safari/IE-stuk anv√§nder mql.addListener/removeListener i st√§llet f√∂r addEventListener.

Om du senare k√∂r test‚Äìmilj√∂, SSR, Storybook etc. utan window ‚Üí h√•rd krasch.

F√∂rslag (bak√•tkompatibelt + s√§krare):

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState(false);

  React.useEffect(() => {
    if (typeof window === "undefined" || !("matchMedia" in window)) {
      setIsMobile(false);
      return;
    }

    const query = `(max-width: ${MOBILE_BREAKPOINT - 1}px)`;
    const mql = window.matchMedia(query);

    const onChange = (e: MediaQueryListEvent | MediaQueryList) => {
      setIsMobile("matches" in e ? e.matches : mql.matches);
    };

    // initial
    setIsMobile(mql.matches);

    if ("addEventListener" in mql) {
      mql.addEventListener("change", onChange as any);
      return () => mql.removeEventListener("change", onChange as any);
    } else {
      // √§ldre API
      // @ts-expect-error legacy Safari
      mql.addListener(onChange);
      // @ts-expect-error legacy Safari
      return () => mql.removeListener(onChange);
    }
  }, []);

  return isMobile;
}


Det h√§r g√∂r ingen skillnad f√∂r ‚Äúvanlig‚Äù anv√§ndare, men g√∂r koden robustare i fler milj√∂er.

2. S√•nt jag skulle fixa / f√∂rb√§ttra √§nd√• (webapp-l√§ge)
2.1 Direkt DOM‚Äì och window‚Äìanv√§ndning ‚Äì samla i sm√• helpers

Du anv√§nder window, document, localStorage, URLSearchParams lite √∂verallt:

ThemeContext ‚Äì s√§tter data-theme direkt p√• document.documentElement.

Profile.tsx ‚Äì window.location.href, manuell blob‚Äìdownload via <a>.

Dashboard.tsx, ActiveSession.tsx, Alternatives.tsx, Warmup.tsx, SessionComplete.tsx ‚Äì l√§ser URL‚Äìparametrar med new URLSearchParams(window.location.search).

PromoCard.tsx, HealthConnectButton.tsx ‚Äì window.open(...).

Det funkar helt ok i en ren SPA, men det ger:

Sv√•rtestat (m√•nga st√§llen att mocka).

Mer jobb den dagen du vill l√§gga till SSR, testa i Node, eller k√∂ra samma logik n√•gon annanstans.

Rekommendation:

Skapa sm√• helpers i t.ex. client/src/lib/platform.ts:

export function openExternal(url: string) {
  if (typeof window !== "undefined") {
    window.open(url, "_blank", "noopener,noreferrer");
  }
}

export function getSearchParams() {
  if (typeof window === "undefined") return new URLSearchParams();
  return new URLSearchParams(window.location.search);
}

export function downloadBlob(blob: Blob, filename: string) {
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  window.URL.revokeObjectURL(url);
}


Och anv√§nd dessa ist√§llet. Det √§r en liten refactor nu, men minskar buggrisk och g√∂r det l√§ttare att √§ndra beteende centralt.

2.2 Rej√§l typning ist√§llet f√∂r any i kritiska fl√∂den

Framf√∂r allt i:

client/src/pages/ActiveSession.tsx

client/src/pages/Alternatives.tsx

client/src/components/EquipmentScanner.tsx (sett delvis)

m.fl.

Du har m√•nga st√§llen med:

sessionLogs.forEach((log: any) => { ... })
const completedLogs = sessionLogs.filter((log: any) => log.completed);


och i Alternatives:

const programData = profile.aiProgramData as any;
programData.phases?.forEach((phase: any) => { ... });


Det h√§r √§r st√§llen d√§r ett f√§ltbyte i API:t (completed ‚Üí isCompleted, exercise.key ‚Üí exercise.exerciseKey) ger tysta logiska buggar i webappen.

Rekommendation:

Anv√§nd typerna fr√•n @shared/schema (z.infer p√• respektive tabell/schema) eller definiera front-end‚Äìspecifika interfaces.

Byt ut any mot dessa typer, s√§rskilt:

session‚Äì/log‚Äìstrukturer

aiProgramData‚Äìstrukturen

svar fr√•n EquipmentScanner/AI-detektion.

Det √§r mer ‚ÄúDX‚Äù-fix √§n akut bug, men det √§r h√§r framtida buggar kommer dyka upp.

2.3 Health Connect & QR/Camera ‚Äì defensivare felhantering

F√∂r webapp-l√§ge √§r det h√§r mest UX-st√§d men minskar konstiga edge-case buggar:

EquipmentScanner:

Du loggar fel vid getUserMedia och visar toast ‚Äì bra.

Jag hade √§ven:

disable:at knappar n√§r isScanning true.

fallback-UI om navigator.mediaDevices saknas (gamla browsers / st√•ende i in-app-webview).

HealthConnectButton:

L√§gg till hantering f√∂r:

refetchConnections() som kastar fel ‚Üí logga + visa toast, stoppa spinner.

Timeout (t.ex. sluta polla efter 2‚Äì3 minuter och visa ‚ÄúAvbruten eller tog f√∂r l√•ng tid‚Äù).

2.4 ThemeContext ‚Äì hantera korrupt localStorage snyggt

Du anv√§nder localStorage f√∂r att spara theme (plus √§ven dismissed tips etc). I ThemeContext kan t.ex. en trasig localStorage‚Äìpost g√∂ra att du f√∂rs√∂ker ladda ett tema som inte finns.

I filen (delvis trunkerad i zippen) ser jag:

function isValidTheme(value: string): value is Theme {
  return ["main", "forest", "purple", "ocean", "sunset", "slate", "crimson", "pink"].includes(value);
}


Bra ‚Äì men se till att du faktiskt anv√§nder den n√§r du l√§ser fr√•n storage, t.ex.:

useEffect(() => {
  try {
    const stored = localStorage.getItem("theme");
    if (stored && isValidTheme(stored)) {
      setThemeState(stored);
      applyThemeToDocument(stored);
    } else {
      applyThemeToDocument("main");
    }
  } catch (error) {
    console.error("Failed to read theme from localStorage", error);
    applyThemeToDocument("main");
  }
  setInitialized(true);
}, []);


P√• samma s√§tt f√∂r dismissedTips i use-training-tips ‚Äì try/catch finns, men se till att fallbacken √§r vettig om parsning misslyckas.

2.5 Sm√• UX/robusthetsdetaljer

N√•gra ‚Äúquality of life‚Äù-grejer som minskar buggrapporter:

URL-parametrar
P√• flera sidor (Dashboard, Warmup, SessionComplete, ActiveSession) h√§mtar ni tab/ids fr√•n window.location.search en g√•ng vid mount.
Om ni b√∂rjar √§ndra query params client-side (utan full reload) kommer de v√§rdena inte uppdateras. Ett litet useSearchParams-hook baserat p√• wouter/window.onpopstate skulle g√∂ra det mer robust.

SetInterval / timers generellt
Se till att alla intervaller och timeouts st√§das upp i useEffect-cleanup om de lever l√§ngre √§n en user action (HealthConnect √§r den tydliga). Det √§r klassisk ‚Äúosynlig‚Äù bugkategori i single-page apps.